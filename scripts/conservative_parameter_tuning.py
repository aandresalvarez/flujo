#!/usr/bin/env python3
"""
Conservative parameter tuning script.

This script applies conservative parameter tuning that focuses on minimal
overhead and selective optimization enabling based on performance impact.
It disables optimizations that cause performance regressions and tunes
parameters for maximum efficiency.
"""

import asyncio
import json
import multiprocessing
import sys
import time
from pathlib import Path

# Import after path setup
from flujo.application.core.ultra_executor import OptimizedExecutorCore

# Add the project root to the Python path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))


def create_conservative_optimized_config():
    """Create a conservative optimized configuration that minimizes overhead."""
    cpu_count = multiprocessing.cpu_count()
    
    # Conservative configuration that disables problematic optimizations
    config_code = f'''# Conservative Optimized ExecutorCore Configuration
# Generated by conservative parameter tuning on {time.strftime("%Y-%m-%d %H:%M:%S")}

from flujo.application.core.ultra_executor import ExecutorCore, OptimizedExecutorCore, OptimizationConfig

def get_conservative_optimized_config() -> OptimizationConfig:
    """Get conservative optimized configuration that minimizes overhead."""
    return OptimizationConfig(
        # Memory optimizations - DISABLED (causing overhead)
        enable_object_pool=False,
        enable_context_optimization=False,
        enable_memory_optimization=False,
        object_pool_max_size=100,  # Minimal if enabled
        object_pool_cleanup_threshold=0.9,  # Less aggressive cleanup
        
        # Execution optimizations - SELECTIVE
        enable_step_optimization=False,  # Disable if causing overhead
        enable_algorithm_optimization=False,  # Disable if causing overhead
        enable_concurrency_optimization=False,  # Disable if causing overhead
        max_concurrent_executions={cpu_count},  # Conservative concurrency
        
        # Telemetry optimizations - MINIMAL
        enable_optimized_telemetry=False,  # Disable to reduce overhead
        enable_performance_monitoring=False,  # Disable to reduce overhead
        telemetry_batch_size=50,  # Smaller batches
        telemetry_flush_interval_seconds=10.0,  # Less frequent flushing
        
        # Error handling optimizations - MINIMAL
        enable_optimized_error_handling=False,  # Disable if causing overhead
        enable_circuit_breaker=False,  # Disable if causing overhead
        error_cache_size=50,  # Minimal cache
        circuit_breaker_failure_threshold=10,  # Less sensitive
        circuit_breaker_recovery_timeout_seconds=60,  # Longer recovery
        
        # Cache optimizations - MINIMAL
        enable_cache_optimization=False,  # Disable if causing overhead
        cache_compression=False,
        cache_ttl_seconds=7200,  # Longer TTL
        cache_max_size=500,  # Smaller cache
        
        # Performance thresholds - RELAXED
        slow_execution_threshold_ms=2000.0,  # Less sensitive
        memory_pressure_threshold_mb=1000.0,  # Higher threshold
        cpu_usage_threshold_percent=90.0,  # Less aggressive
        
        # Automatic optimization - DISABLED
        enable_automatic_optimization=False,  # Disable to prevent overhead
        optimization_analysis_interval_seconds=300.0,  # Less frequent
        performance_degradation_threshold=0.5,  # Less sensitive
        
        # Backward compatibility
        maintain_backward_compatibility=True,
        allow_runtime_changes=False,  # Disable runtime changes
        config_validation_enabled=False  # Disable validation overhead
    )

# Component-specific conservative parameters
CONSERVATIVE_OBJECT_POOL_CONFIG = {{
    "max_pool_size": 50,  # Very small pools
    "max_pools": 10,  # Few pools
    "cleanup_threshold": 0.9,  # Less aggressive cleanup
    "stats_enabled": False  # Disable stats overhead
}}

CONSERVATIVE_CONTEXT_MANAGER_CONFIG = {{
    "cache_size": 64,  # Very small cache
    "merge_cache_size": 32,  # Very small merge cache
    "ttl_seconds": 7200,  # Longer TTL
    "enable_cow": False,  # Disable COW optimization
    "enable_stats": False  # Disable stats overhead
}}

CONSERVATIVE_TELEMETRY_CONFIG = {{
    "enable_tracing": False,  # Disable tracing
    "enable_metrics": False,  # Disable metrics
    "enable_sampling": True,
    "sampling_rate": 0.01,  # Very low sampling (1%)
    "batch_size": 10,  # Very small batches
    "flush_interval": 30.0,  # Infrequent flushing
    "enable_stats": False  # Disable stats overhead
}}

CONSERVATIVE_RESOURCE_MANAGER_CONFIG = {{
    "monitoring_interval": 5.0,  # Less frequent monitoring
    "adaptation_interval": 30.0,  # Less frequent adaptation
    "enable_telemetry": False  # Disable telemetry overhead
}}
'''
    return config_code


def update_optimization_components_for_conservative_mode():
    """Update optimization component default parameters for conservative mode."""
    
    # Update OptimizedObjectPool defaults
    object_pool_updates = {
        "max_pool_size": 50,
        "max_pools": 10,
        "cleanup_threshold": 0.9,
        "stats_enabled": False
    }
    
    # Update OptimizedContextManager defaults
    context_manager_updates = {
        "cache_size": 64,
        "merge_cache_size": 32,
        "ttl_seconds": 7200,
        "enable_cow": False,
        "enable_stats": False
    }
    
    # Update OptimizedTelemetry defaults
    telemetry_updates = {
        "enable_tracing": False,
        "enable_metrics": False,
        "sampling_rate": 0.01,
        "batch_size": 10,
        "flush_interval": 30.0,
        "enable_stats": False
    }
    
    # Update AdaptiveResourceManager defaults
    resource_manager_updates = {
        "monitoring_interval": 5.0,
        "adaptation_interval": 30.0,
        "enable_telemetry": False
    }
    
    return {
        "object_pool": object_pool_updates,
        "context_manager": context_manager_updates,
        "telemetry": telemetry_updates,
        "resource_manager": resource_manager_updates
    }


def apply_conservative_parameter_updates():
    """Apply conservative parameter updates to the optimization components."""
    
    # Update OptimizationConfig in ultra_executor.py
    ultra_executor_path = "flujo/application/core/ultra_executor.py"
    
    try:
        with open(ultra_executor_path, 'r') as f:
            content = f.read()
        
        # Update OptimizationConfig defaults
        conservative_config_section = '''@dataclass
class OptimizationConfig:
    """Configuration for ExecutorCore optimizations."""
    
    # Memory optimizations - CONSERVATIVE
    enable_object_pool: bool = False  # Disabled due to overhead
    enable_context_optimization: bool = False  # Disabled due to overhead
    enable_memory_optimization: bool = False  # Disabled due to overhead
    object_pool_max_size: int = 50  # Minimal if enabled
    object_pool_cleanup_threshold: float = 0.9  # Less aggressive cleanup
    
    # Execution optimizations - CONSERVATIVE
    enable_step_optimization: bool = False  # Disabled due to overhead
    enable_algorithm_optimization: bool = False  # Disabled due to overhead
    enable_concurrency_optimization: bool = False  # Disabled due to overhead
    max_concurrent_executions: Optional[int] = None  # Auto-detect if None
    
    # Telemetry optimizations - MINIMAL
    enable_optimized_telemetry: bool = False  # Disabled due to overhead
    enable_performance_monitoring: bool = False  # Disabled due to overhead
    telemetry_batch_size: int = 10  # Smaller batches
    telemetry_flush_interval_seconds: float = 30.0  # Less frequent flushing
    
    # Error handling optimizations - MINIMAL
    enable_optimized_error_handling: bool = False  # Disabled due to overhead
    enable_circuit_breaker: bool = False  # Disabled due to overhead
    error_cache_size: int = 50  # Minimal cache
    circuit_breaker_failure_threshold: int = 10  # Less sensitive
    circuit_breaker_recovery_timeout_seconds: int = 60  # Longer recovery
    
    # Cache optimizations - MINIMAL
    enable_cache_optimization: bool = False  # Disabled due to overhead
    cache_compression: bool = False
    cache_ttl_seconds: int = 7200  # Longer TTL
    cache_max_size: int = 500  # Smaller cache'''
        
        # Find and replace the OptimizationConfig class
        import re
        pattern = r'@dataclass\nclass OptimizationConfig:.*?cache_max_size: int = \d+'
        
        if re.search(pattern, content, re.DOTALL):
            updated_content = re.sub(pattern, conservative_config_section, content, flags=re.DOTALL)
            
            with open(ultra_executor_path, 'w') as f:
                f.write(updated_content)
            
            print(f"✅ Updated {ultra_executor_path} with conservative parameters")
            return True
        else:
            print(f"⚠️  Could not find OptimizationConfig pattern in {ultra_executor_path}")
            return False
    
    except Exception as e:
        print(f"❌ Error updating {ultra_executor_path}: {e}")
        return False


async def validate_conservative_configuration():
    """Validate the conservative configuration by running a simple performance test."""
    try:
        from flujo.application.core.ultra_executor import OptimizationConfig
        from flujo.domain.dsl.step import Step, StepConfig
        from flujo.testing.utils import StubAgent
        
        # Create conservative config
        config = OptimizationConfig(
            enable_object_pool=False,
            enable_context_optimization=False,
            enable_memory_optimization=False,
            enable_step_optimization=False,
            enable_algorithm_optimization=False,
            enable_concurrency_optimization=False,
            enable_optimized_telemetry=False,
            enable_performance_monitoring=False,
            enable_optimized_error_handling=False,
            enable_circuit_breaker=False,
            enable_cache_optimization=False,
            enable_automatic_optimization=False,
            max_concurrent_executions=multiprocessing.cpu_count(),
            maintain_backward_compatibility=True,
            allow_runtime_changes=False,
            config_validation_enabled=False
        )
        
        # Create executor
        executor = OptimizedExecutorCore(optimization_config=config)
        
        # Create test step
        step = Step.model_validate({
            "name": "conservative_test",
            "agent": StubAgent(["test_output"]),
            "config": StepConfig(max_retries=1),
        })
        
        # Run performance test
        times = []
        for _ in range(10):
            start_time = time.perf_counter()
            try:
                await executor.execute(step, {"test": "conservative"})
                end_time = time.perf_counter()
                times.append(end_time - start_time)
            except Exception as e:
                print(f"Test execution failed: {e}")
                return False
        
        if times:
            avg_time = sum(times) / len(times)
            print("✅ Conservative configuration validation successful")
            print(f"   Average execution time: {avg_time:.6f}s")
            print("   All optimizations disabled for minimal overhead")
            return True
        else:
            print("❌ No successful test executions")
            return False
    
    except Exception as e:
        print(f"❌ Conservative configuration validation failed: {e}")
        return False


async def main():
    """Main conservative tuning function."""
    print("=" * 60)
    print("CONSERVATIVE PARAMETER TUNING")
    print("=" * 60)
    print("This approach disables optimizations that cause performance")
    print("regressions and uses minimal overhead configurations.")
    print()
    
    # Step 1: Apply conservative parameter updates
    print("Step 1: Applying conservative parameter updates...")
    success = apply_conservative_parameter_updates()
    
    if not success:
        print("❌ Failed to apply conservative parameter updates")
        return 1
    
    # Step 2: Generate conservative configuration file
    print("\nStep 2: Generating conservative configuration file...")
    config_code = create_conservative_optimized_config()
    
    with open("conservative_executor_config.py", 'w') as f:
        f.write(config_code)
    
    print("✅ Conservative configuration saved to conservative_executor_config.py")
    
    # Step 3: Validate conservative configuration
    print("\nStep 3: Validating conservative configuration...")
    validation_success = await validate_conservative_configuration()
    
    if not validation_success:
        print("❌ Conservative configuration validation failed")
        return 1
    
    # Step 4: Generate summary
    print("\n" + "=" * 60)
    print("CONSERVATIVE TUNING SUMMARY")
    print("=" * 60)
    print("✅ Applied conservative parameter tuning")
    print("✅ Disabled optimizations causing performance regressions:")
    print("   - Object pooling (overhead)")
    print("   - Context optimization (overhead)")
    print("   - Memory optimization (overhead)")
    print("   - Step optimization (overhead)")
    print("   - Algorithm optimization (overhead)")
    print("   - Concurrency optimization (overhead)")
    print("   - Optimized telemetry (overhead)")
    print("   - Performance monitoring (overhead)")
    print("   - Optimized error handling (overhead)")
    print("   - Circuit breaker (overhead)")
    print("   - Cache optimization (overhead)")
    print("   - Automatic optimization (overhead)")
    print()
    print("✅ Configuration focuses on minimal overhead and maximum compatibility")
    print("✅ All optimizations can be selectively re-enabled if needed")
    
    # Step 5: Save tuning results
    results = {
        "strategy": "conservative",
        "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
        "disabled_optimizations": [
            "object_pool",
            "context_optimization",
            "memory_optimization",
            "step_optimization",
            "algorithm_optimization",
            "concurrency_optimization",
            "optimized_telemetry",
            "performance_monitoring",
            "optimized_error_handling",
            "circuit_breaker",
            "cache_optimization",
            "automatic_optimization"
        ],
        "rationale": "Optimizations were causing significant performance regressions",
        "approach": "Disable all optimizations and use baseline ExecutorCore performance",
        "validation_successful": validation_success
    }
    
    with open("conservative_tuning_results.json", 'w') as f:
        json.dump(results, f, indent=2)
    
    print("✅ Conservative tuning results saved to conservative_tuning_results.json")
    
    return 0


if __name__ == "__main__":
    exit_code = asyncio.run(main())
    sys.exit(exit_code)