from __future__ import annotations

import json
import re
from pathlib import Path
from typing import Any, Iterable

try:
    import yaml
except Exception:  # pragma: no cover - optional dependency
    yaml = None


def load_openapi_spec(spec_path: str) -> dict[str, Any]:
    """Load an OpenAPI spec from JSON or YAML."""
    path = Path(spec_path)
    data = path.read_text(encoding="utf-8")
    if path.suffix.lower() in {".json"}:
        return dict(json.loads(data))
    if yaml is None:
        raise RuntimeError("PyYAML is required to load non-JSON OpenAPI specs")
    loaded = yaml.safe_load(data)
    if not isinstance(loaded, dict):
        raise ValueError("OpenAPI spec did not load to a mapping")
    return dict(loaded)


def _safe_name(name: str) -> str:
    """Sanitize a name into snake_case."""
    name = re.sub(r"[^0-9a-zA-Z]+", "_", name)
    name = re.sub(r"_+", "_", name).strip("_")
    return name.lower() or "operation"


def _iter_operations(spec: dict[str, Any]) -> Iterable[tuple[str, str, dict[str, Any]]]:
    paths = spec.get("paths", {}) or {}
    for path, ops in paths.items():
        if not isinstance(ops, dict):
            continue
        for method, op in ops.items():
            if method.lower() not in {"get", "post", "put", "patch", "delete"}:
                continue
            if not isinstance(op, dict):
                continue
            yield path, method.lower(), op


def generate_openapi_agents(
    *,
    spec: dict[str, Any],
    models_package: str,
    output_dir: Path,
    agents_filename: str = "openapi_agents.py",
) -> Path:
    """Generate agent factory code for OpenAPI operations."""
    output_dir.mkdir(parents=True, exist_ok=True)
    (output_dir / "__init__.py").touch(exist_ok=True)
    agents_path = output_dir / agents_filename

    ops = list(_iter_operations(spec))
    if not ops:
        raise ValueError("No operations found in OpenAPI spec")

    functions: list[str] = []
    for path, method, op in ops:
        op_id = op.get("operationId") or f"{method}_{path}"
        fname = _safe_name(op_id)
        functions.append(
            f"""
async def {fname}(
    *,
    base_url: str,
    path_params: dict[str, Any] | None = None,
    query: dict[str, Any] | None = None,
    headers: dict[str, str] | None = None,
    body: Any | None = None,
) -> dict[str, Any]:
    \"\"\"Call {method.upper()} {path} from the generated agent.\"\"\"
    url_path = "{path}".format(**(path_params or {{}}))
    return await _http_request(
        method="{method.upper()}",
        base_url=base_url,
        url_path=url_path,
        query=query,
        headers=headers,
        json_body=body,
    )
"""
        )

    func_list = ", ".join(_safe_name(op.get("operationId") or f"{m}_{p}") for p, m, op in ops)
    content = f'''"""
Auto-generated OpenAPI agent wrappers.

This file was generated by flujo dev import-openapi.
"""
from __future__ import annotations

from typing import Any

import httpx

from flujo.agents.wrapper import make_agent_async, AsyncAgentWrapper


async def _http_request(
    *,
    method: str,
    base_url: str,
    url_path: str,
    query: dict[str, Any] | None,
    headers: dict[str, str] | None,
    json_body: Any | None,
) -> dict[str, Any]:
    url = base_url.rstrip("/") + url_path
    async with httpx.AsyncClient() as client:
        response = await client.request(method, url, params=query, headers=headers, json=json_body)
        response.raise_for_status()
        try:
            return response.json()
        except Exception:
            return {{"status_code": response.status_code, "content": response.text}}


{"".join(functions)}

def make_openapi_agent(
    *,
    base_url: str,
    model: str = "openai:gpt-4o-mini",
    system_prompt: str | None = None,
) -> AsyncAgentWrapper:
    \"\"\"Create an agent with tools for all operations in the spec.\"\"\"
    tools = [{func_list}]
    prompt = system_prompt or "You are an API caller that uses provided tools to call the target OpenAPI service."
    return make_agent_async(
        model=model,
        system_prompt=prompt,
        tools=tools,
        output_type=dict,
        metadata={{"openapi_models_package": "{models_package}"}},
    )
'''
    agents_path.write_text(content, encoding="utf-8")
    return agents_path
