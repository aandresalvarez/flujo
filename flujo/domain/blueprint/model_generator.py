from __future__ import annotations

from typing import Any, Dict, List, Optional, Tuple, Type

from pydantic import BaseModel, Field, create_model


JsonSchema = Dict[str, Any]


def _python_type_for_json_schema(schema: JsonSchema, *, name_hint: str = "Value") -> Any:
    t: Optional[str] = schema.get("type")
    if t is None:
        # Fall back to Any when type is not specified
        return Any

    # Handle enum on primitives via Literal if present
    enum_vals = schema.get("enum")

    if t == "string":
        base_type = str
        if isinstance(enum_vals, list) and enum_vals:
            try:
                # Use typing.Literal for enum validation
                from typing import Literal  # type: ignore

                literal_type = Literal[tuple(enum_vals)]  # type: ignore[index]
                return literal_type
            except Exception:
                return base_type
        return base_type
    if t == "integer":
        return int
    if t == "number":
        return float
    if t == "boolean":
        return bool
    if t == "array":
        items = schema.get("items", {})
        item_type = _python_type_for_json_schema(items, name_hint=f"{name_hint}Item")
        from typing import List as _List

        return _List[item_type]  # type: ignore[index]
    if t == "object":
        # Nested object without explicit properties -> generic dict
        if not isinstance(schema.get("properties"), dict):
            from typing import Dict as _Dict

            return _Dict[str, Any]
        # For objects with properties, a model will be generated by caller
        return dict

    # Fallback
    return Any


def generate_model_from_schema(name: str, schema: JsonSchema) -> Type[BaseModel]:
    """Generate a Pydantic BaseModel from a JSON Schema dictionary.

    The generator supports core JSON Schema features used by Flujo blueprints:
    - type: string, integer, number, boolean, object, array
    - properties, required
    - enum on primitives (via typing.Literal)
    - description propagated to Field

    For non-object primitives, a wrapper model with a single field 'value' is returned.
    """
    model_name = (
        "".join(part.capitalize() for part in name.replace("-", "_").split("_")) or "DynamicModel"
    )

    schema_type = schema.get("type")

    # Primitive wrappers
    if schema_type != "object":
        annotation = _python_type_for_json_schema(schema, name_hint="Value")
        fields: Dict[str, Tuple[Any, Any]] = {
            "value": (annotation, ...),
        }
        # Carry field description if any
        desc = schema.get("description")
        if desc:
            fields["value"] = (annotation, Field(..., description=str(desc)))
        return create_model(model_name, **fields)  # type: ignore[return-value]

    # Object handling
    properties: Dict[str, Any] = schema.get("properties") or {}
    required: List[str] = list(schema.get("required") or [])

    fields: Dict[str, Tuple[Any, Any]] = {}
    for prop_name, prop_schema in properties.items():
        prop_type = _python_type_for_json_schema(prop_schema, name_hint=prop_name)

        # If nested object with properties, recursively create a submodel
        if prop_schema.get("type") == "object" and isinstance(prop_schema.get("properties"), dict):
            sub_name = f"{model_name}{''.join(part.capitalize() for part in prop_name.split('_'))}"
            prop_type = generate_model_from_schema(sub_name, prop_schema)

        is_required = prop_name in required
        default = ... if is_required else None

        field_kwargs: Dict[str, Any] = {}
        if "description" in prop_schema:
            field_kwargs["description"] = str(prop_schema["description"])

        # If enum exists on primitives, the type was converted to Literal already
        if not is_required:
            from typing import Optional as _Optional

            prop_type = _Optional[prop_type]  # type: ignore[index]

        if field_kwargs:
            fields[prop_name] = (prop_type, Field(default, **field_kwargs))
        else:
            fields[prop_name] = (prop_type, default)

    if not fields:
        # Empty object schema -> allow arbitrary mapping
        fields["data"] = (Dict[str, Any], Field(default_factory=dict))

    return create_model(model_name, **fields)  # type: ignore[return-value]


__all__ = ["generate_model_from_schema"]
