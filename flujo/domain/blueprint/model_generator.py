from __future__ import annotations

from typing import Any, Dict, List, Optional, Type

from pydantic import BaseModel, Field, create_model


JsonSchema = Dict[str, Any]


def _python_type_for_json_schema(schema: JsonSchema, *, name_hint: str = "Value") -> Any:
    t: Optional[str] = schema.get("type")
    if t is None:
        # Fall back to Any when type is not specified
        return Any

    if t == "string":
        return str
    if t == "integer":
        return int
    if t == "number":
        return float
    if t == "boolean":
        return bool
    if t == "array":
        # Keep item typing permissive for runtime compatibility
        from typing import List as _List
        from typing import Any as _Any

        return _List[_Any]
    if t == "object":
        # Nested object without explicit properties -> generic dict
        if not isinstance(schema.get("properties"), dict):
            from typing import Dict as _Dict

            return _Dict[str, Any]
        # For objects with properties, a model will be generated by caller
        return dict

    # Fallback
    return Any


def generate_model_from_schema(name: str, schema: JsonSchema) -> Type[BaseModel]:
    """Generate a Pydantic BaseModel from a JSON Schema dictionary.

    The generator supports core JSON Schema features used by Flujo blueprints:
    - type: string, integer, number, boolean, object, array
    - properties, required
    - enum on primitives (via typing.Literal)
    - description propagated to Field

    For non-object primitives, a wrapper model with a single field 'value' is returned.
    """
    model_name = (
        "".join(part.capitalize() for part in name.replace("-", "_").split("_")) or "DynamicModel"
    )

    schema_type = schema.get("type")

    # Primitive wrappers
    if schema_type != "object":
        annotation = _python_type_for_json_schema(schema, name_hint="Value")
        primitive_fields: Dict[str, Any] = {
            "value": (annotation, ...),
        }
        # Carry field description if any
        desc = schema.get("description")
        if desc:
            primitive_fields["value"] = (annotation, Field(..., description=str(desc)))
        from typing import cast as _cast

        return _cast(Type[BaseModel], create_model(model_name, **primitive_fields))

    # Object handling
    properties: Dict[str, Any] = schema.get("properties") or {}
    required: List[str] = list(schema.get("required") or [])

    fields: Dict[str, Any] = {}
    for prop_name, prop_schema in properties.items():
        prop_type = _python_type_for_json_schema(prop_schema, name_hint=prop_name)

        # If nested object with properties, recursively create a submodel
        if prop_schema.get("type") == "object" and isinstance(prop_schema.get("properties"), dict):
            sub_name = f"{model_name}{''.join(part.capitalize() for part in prop_name.split('_'))}"
            prop_type = generate_model_from_schema(sub_name, prop_schema)

        is_required = prop_name in required
        default = ... if is_required else None

        field_kwargs: Dict[str, Any] = {}
        if "description" in prop_schema:
            field_kwargs["description"] = str(prop_schema["description"])

        # Optionality is expressed by default=None for pydantic models

        if field_kwargs:
            fields[prop_name] = (prop_type, Field(default, **field_kwargs))
        else:
            fields[prop_name] = (prop_type, default)

    if not fields:
        # Empty object schema -> allow arbitrary mapping
        fields["data"] = (Dict[str, Any], Field(default_factory=dict))

    from typing import cast as _cast

    return _cast(Type[BaseModel], create_model(model_name, **fields))


__all__ = ["generate_model_from_schema"]
