version: "0.1"
name: "architect"

agents:
  # Decomposer
  decomposer:
    model: "openai:gpt-5"
    timeout: 120
    system_prompt: |
      You are a system architect. Decompose the user's goal into a list of simple, actionable steps.
      Ensure you create separate, distinct steps for repetitive actions (e.g., if asked to create 3 items, create 3 separate draft steps).
      Think step-by-step to build a complete workflow from research to final output.
      Output ONLY a model: { steps: [{ step_name: string, purpose: string }] }.
    output_schema:
      type: object
      properties:
        steps:
          type: array
          items:
            type: object
            properties:
              step_name: { type: string }
              purpose: { type: string }
            required: [step_name, purpose]
      required: [steps]

  # Tool matcher (single step → best tool or null)
  tool_matcher:
    model: "openai:gpt-5-mini"
    timeout: 60
    system_prompt: |
      You are a tool mapping expert. For the given step description, choose the best implementation.
      Input context: { step_name, purpose, available_skills }.
      - If a skill from available_skills fits, return its id in tool_name.
      - If no skill is a perfect match, return tool_name: null and set implementation to a concise description.
      Output ONLY: { step_name: string, implementation: string, tool_name: string|null }.
    output_schema:
      type: object
      properties:
        step_name: { type: string }
        implementation: { type: string }
        tool_name: { type: ["string", "null"] }
      required: [step_name, implementation]

  # Plan presenter (user-facing summary)
  plan_presenter:
    model: "openai:gpt-5"
    timeout: 120
    system_prompt: |
      You are a helpful project manager. You will be given a JSON plan. Summarize it as a numbered list
      describing each step and its implementation. Ask for confirmation: "Does this plan look correct? (Y/n)".
    output_schema:
      type: string

  # YAML writer (self-contained Flujo YAML guide)
  yaml_writer:
    model: "openai:gpt-5"
    timeout: 180
    system_prompt: |
      You are an expert at writing Flujo YAML blueprints. Convert a user's goal and a structured JSON plan into a complete, valid pipeline.yaml.
      STRICT RULES:
      - version MUST be "0.1".
      - Each step MUST use the key 'name' (NOT 'id').
      - Built-in skills MUST use shape:
        agent: { id: <skill_id>, params: { ... } }
      - For http fetch: use flujo.builtins.http_get with params.url.
      - For text extraction: use flujo.builtins.extract_from_text with params.text and params.schema.
      - For file write: use flujo.builtins.fs_write_file with params.path and params.content.
      - Use proper Jinja references, e.g., "{{ fetch_step.body }}"; do NOT pass full previous objects where strings are required.
      - Avoid fields not in schema (e.g., don't use 'id', 'uses' in steps; use 'name' and 'agent').
      - Output ONLY a JSON object with keys 'generated_yaml' and 'yaml_text', both containing the identical raw YAML text. Do not include any other prose, explanations, wrappers, or markdown fences.
    output_schema:
      type: object
      properties:
        generated_yaml: { type: string }
        yaml_text: { type: string }
      required: [generated_yaml, yaml_text]

  # Repair agent
  repair_agent:
    model: "openai:gpt-5"
    timeout: 120
    system_prompt: |
      You are a Flujo YAML debugger. Fix the provided invalid YAML based on a validation error.
      Make the MINIMUM necessary change to fix the error while preserving the original intent.
      Output ONLY: { generated_yaml: string }.
    output_schema:
      type: object
      properties:
        generated_yaml: { type: string }

steps:
  # Stage 1: Planning & Tool Mapping
  - kind: step
    name: DecomposeGoal
    uses: agents.decomposer
    updates_context: true

  - kind: step
    name: PrepareStepsForMapping
    agent: { id: "flujo.builtins.extract_decomposed_steps" }
    updates_context: true

  - kind: step
    name: DiscoverSkills
    agent: { id: "flujo.builtins.discover_skills" }
    updates_context: true

  - kind: map
    name: MapStepsToTools
    map:
      iterable_input: "prepared_steps_for_mapping"
      body:
        - kind: step
          name: PrepareMatchInput
          agent: { id: "flujo.builtins.build_tool_match_input" }
        - kind: step
          name: InspectPreparedMatchInput
          agent: { id: "flujo.builtins.passthrough" }
        - kind: step
          name: MatchTool
          uses: agents.tool_matcher
    updates_context: true

  - kind: step
    name: AggregatePlan
    agent: { id: "flujo.builtins.aggregate_plan" }
    updates_context: true

  # Stage 2: Generate YAML directly
  - kind: step
    name: GenerateBlueprint
    uses: agents.yaml_writer
    updates_context: true

  # Stage 3: Validate and (if needed) repair YAML
  - kind: loop
    name: ValidateAndRepair
    loop:
      max_loops: 3
      exit_condition: "flujo.builtins.exit_when_yaml_valid"
      body:
        - kind: step
          name: ExtractYaml
          agent: { id: "flujo.builtins.extract_yaml_text" }
          updates_context: true

        - kind: step
          name: ValidateYaml
          agent: { id: "flujo.builtins.validate_yaml" }
          input:
            yaml_text: "{{ context.yaml_text }}"

        - kind: step
          name: CaptureValidation
          agent: { id: "flujo.builtins.capture_validation_report" }
          updates_context: true

        - kind: conditional
          name: ValidityBranch
          condition: "flujo.builtins.select_validity_branch"
          branches:
            valid:
              - kind: step
                name: ReturnYamlForCli
                agent: { id: "flujo.builtins.return_yaml_for_cli" }
                input: "{{ context.yaml_text }}"
                updates_context: true
            invalid:
              # First try deterministic repair, then re-validate
              - kind: step
                name: DeterministicRepair
                agent: { id: "flujo.builtins.repair_yaml_ruamel" }
                input:
                  yaml_text: "{{ context.yaml_text }}"

              - kind: step
                name: RefreshYamlTextAfterDeterministic
                agent: { id: "flujo.builtins.extract_yaml_text" }
                updates_context: true

              - kind: step
                name: RevalidateAfterDeterministic
                agent: { id: "flujo.builtins.validate_yaml" }
                input:
                  yaml_text: "{{ context.yaml_text }}"

              - kind: step
                name: CaptureValidationAfterDeterministic
                agent: { id: "flujo.builtins.capture_validation_report" }
                updates_context: true

              - kind: conditional
                name: AfterDeterministicBranch
                condition: "flujo.builtins.select_validity_branch"
                branches:
                  valid:
                    - kind: step
                      name: ReturnYamlForCli
                      agent: { id: "flujo.builtins.return_yaml_for_cli" }
                      input: "{{ context.yaml_text }}"
                      updates_context: true
                  invalid:
                    - kind: step
                      name: ExtractValidationErrors
                      agent: { id: "flujo.builtins.extract_validation_errors" }
                      input: "{{ previous_step }}"
                      updates_context: true

                    - kind: step
                      name: RepairYamlLLM
                      uses: agents.repair_agent
                      input:
                        invalid_yaml: "{{ context.yaml_text }}"
                        validation_errors: "{{ context.validation_errors }}"

                    - kind: step
                      name: RefreshYamlTextAfterLLM
                      agent: { id: "flujo.builtins.extract_yaml_text" }
                      updates_context: true

                    - kind: step
                      name: RevalidateAfterLLM
                      agent: { id: "flujo.builtins.validate_yaml" }
                      input:
                        yaml_text: "{{ context.yaml_text }}"

                    - kind: step
                      name: CaptureValidationAfterLLM
                      agent: { id: "flujo.builtins.capture_validation_report" }
                      updates_context: true

  # Stage 4: Finalize output — write to disk only if valid; else emit clear error
  - kind: conditional
    name: FinalizeOutput
    condition: "flujo.builtins.compute_validity_key"
    branches:
      valid:
        - kind: step
          name: WriteYamlToDisk
          agent: { id: "flujo.builtins.write_pipeline_yaml", params: { path: "pipeline.yaml" } }
          input: "{{ context.yaml_text }}"
      invalid:
        - kind: step
          name: EmitValidationFailure
          agent: { id: "flujo.builtins.stringify" }
          input: "Validation failed after validation/repair attempts. Errors: {{ context.validation_errors }}"
