version: "0.1"
name: "architect"

agents:
  # Decomposer
  decomposer:
    model: "openai:gpt-4o"
    timeout: 120
    system_prompt: |
      You are a system architect. Decompose the user's goal into a list of simple, actionable steps.
      Output ONLY a model: { steps: [{ step_name: string, purpose: string }] }.
    output_schema:
      type: object
      properties:
        steps:
          type: array
          items:
            type: object
            properties:
              step_name: { type: string }
              purpose: { type: string }
            required: [step_name, purpose]
      required: [steps]

  # Tool matcher (single step → best tool or null)
  tool_matcher:
    model: "openai:gpt-4o"
    timeout: 60
    system_prompt: |
      You are a tool mapping expert. For the given step description, choose the best implementation.
      Input context: { step_name, purpose, available_skills }.
      - If a skill from available_skills fits, return its id in tool_name.
      - If no skill is a perfect match, return tool_name: null and set implementation to a concise description.
      Output ONLY: { step_name: string, implementation: string, tool_name: string|null }.
    output_schema:
      type: object
      properties:
        step_name: { type: string }
        implementation: { type: string }
        tool_name: { type: ["string", "null"] }
      required: [step_name, implementation]

  # Plan presenter (user-facing summary)
  plan_presenter:
    model: "openai:gpt-4o"
    timeout: 60
    system_prompt: |
      You are a helpful project manager. You will be given a JSON plan. Summarize it as a numbered list
      describing each step and its implementation. Ask for confirmation: "Does this plan look correct? (Y/n)".
    output_schema:
      type: string

  # YAML writer (self-contained Flujo YAML guide)
  yaml_writer:
    model: "openai:gpt-4o"
    timeout: 180
    system_prompt: |
      You are an expert at writing Flujo YAML blueprints. Convert a user's goal and a structured JSON plan into a complete, valid pipeline.yaml.
      STRICT RULES:
      - version MUST be "0.1".
      - Each step MUST use the key 'name' (NOT 'id').
      - Built-in skills MUST use shape:
        agent: { id: <skill_id>, params: { ... } }
      - For http fetch: use flujo.builtins.http_get with params.url.
      - For text extraction: use flujo.builtins.extract_from_text with params.text and params.schema.
      - For file write: use flujo.builtins.fs_write_file with params.path and params.content.
      - Use proper Jinja references, e.g., "{{ fetch_step.body }}"; do NOT pass full previous objects where strings are required.
      - Avoid fields not in schema (e.g., don't use 'id', 'uses' in steps; use 'name' and 'agent').
      Output ONLY: { generated_yaml: string } containing raw YAML.
    output_schema:
      type: object
      properties:
        generated_yaml: { type: string }
      required: [generated_yaml]

  # Repair agent
  repair_agent:
    model: "openai:gpt-4o"
    timeout: 120
    system_prompt: |
      You are a Flujo YAML debugger. Fix the provided invalid YAML based on a validation error.
      Make the MINIMUM necessary change to fix the error while preserving the original intent.
      Output ONLY: { generated_yaml: string }.
    output_schema:
      type: object
      properties:
        generated_yaml: { type: string }

steps:
  # Stage 1: Planning & Tool Mapping
  - kind: step
    name: DecomposeGoal
    uses: agents.decomposer
    updates_context: true

  - kind: step
    name: PrepareStepsForMapping
    agent: { id: "flujo.builtins.extract_decomposed_steps" }
    updates_context: true

  - kind: step
    name: DiscoverSkills
    agent: { id: "flujo.builtins.discover_skills" }
    updates_context: true

  - kind: map
    name: MapStepsToTools
    map:
      iterable_input: "prepared_steps_for_mapping"
      body:
        - kind: step
          name: MatchTool
          uses: agents.tool_matcher
    updates_context: true

  - kind: step
    name: AggregatePlan
    agent: { id: "flujo.builtins.aggregate_plan" }
    input: "{{ previous_step }}"
    updates_context: true

  # Stage 2: Generate YAML directly (simplified for testing)
  - kind: step
    name: GenerateBlueprint
    uses: agents.yaml_writer
    input: "{{ context.aggregated_plan }}"

  # Extract string and place in context (Output: dict)
  - kind: step
    name: ExtractGeneratedYaml
    agent: { id: "flujo.builtins.extract_yaml_text" }
    input: "{{ previous_step }}"
    updates_context: true

  # ✨ THE FIX: Final Emission Step ✨
  # This is now the last step. Its output is what the CLI receives.
  - kind: step
    name: EmitFinalYaml
    agent: { id: "flujo.builtins.return_yaml_for_cli" }
    input: "{{ context.yaml_text }}"
