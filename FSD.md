# FSD: Declarative YAML UX vNext (Expressions, Loop State, Transforms, Agentic Loop)

Author: Flujo Team
Status: In Progress (M1–M2 Completed)
Target Release: staged across Milestones (M1–M5)

## 1) Goals & Non‑Goals

- Goals:
  - Reduce custom Python glue by empowering YAML: conditions, state, and data transforms.
  - Preserve Flujo’s non‑negotiables: policy dispatch, control‑flow exceptions, idempotency, quotas, centralized config, agent factories.
  - Keep new features as compiler/runtime sugar on top of existing primitives; avoid executor core branching.
  - Improve first‑run experience and PR readability for pipelines generated by `flujo create`.
- Non‑Goals:
  - Do not replace the typed DSL; YAML continues to compile to it.
  - Do not introduce reactive (post‑execution) resource checks.
  - Do not relax exception orchestration or change HITL semantics.

## 2) User Value Summary

- Simple branching and loop termination without Python helper functions.
- Declarative loop state (append/set/merge) without manual mappers.
- Common data transforms as built‑ins (CSV, aggregate, select, flatten).
- Safer, clearer templating with a few well‑scoped filters (join, upper, lower, length, tojson).
- A readable conversational loop (`agentic_loop`) as YAML sugar that compiles into existing steps.

## 3) Alignment With Team Guide (Non‑Negotiables)

- Policy‑Driven Execution: New behaviors live in the blueprint compiler and built‑ins; any step execution logic remains in policies (`step_policies.py`). No `isinstance(step, ...)` added to core executors.
- Control Flow Exceptions: `PausedException`, `PipelineAbortSignal`, `InfiniteRedirectError` must propagate. Expression evaluation and loop state sugar never convert control‑flow into data failures.
- Context Idempotency: Loop state operations apply on an isolated iteration context (`ContextManager.isolate()`), merged back only on successful iteration per current policy.
- Proactive Quotas: Transforms are CPU‑only with zero usage. No reactive checks are introduced. Existing Reserve → Execute → Reconcile remains intact.
- Centralized Configuration: All toggles/allow‑lists sourced via `infra.config_manager` and `flujo.toml` (no env or direct file reads inside policies/domain logic).
- Agent Creation: Any LLM helpers (if added later) use `flujo.agents` factories (`make_agent_async`, `make_agent`).

## 4) Roadmap Fit (ROADMAP.md)

- Phase 1 (Generate): Strengthens `flujo.builtins`, improves YAML created by `flujo create`, reduces boilerplate (faster TTFR, higher first‑try validity).
- Phase 2 (Run & Debug): Simpler flows → cleaner traces and clearer diffs; branch decisions from expressions annotated in telemetry.
- Phase 3 (Teams & Governance): Small, explicit YAML changes; CPU‑only transforms; no budget regressions; supports side‑effect warnings via registry metadata.

## 5) Scope Overview (Features)

1. Built‑in Data Transforms (M1)
   - `to_csv`: list[dict] → CSV string
   - `aggregate`: operations: `sum`, `avg`, `count` over a numeric field in list[dict]
   - `select_fields`: projection/rename fields from dict or list[dict]
   - `flatten`: list[list[T]] → list[T]

2. Template Filters (M2)
   - `join`, `upper`, `lower`, `length`, `tojson` in `AdvancedPromptFormatter`.

3. Expression Strings for Conditions (M3)
   - Blueprint keys: `condition_expression` (conditional), `exit_expression` (loop).
   - Safe, sandboxed mini‑language: dotted access, `==`, `!=`, `<`, `<=`, `>`, `>=`, `in`, `and`/`or`/`not`, truthiness on strings/collections, numeric comparisons. No attribute mutation, I/O, or function calls.
   - Loader compiles expressions into callables equivalent to today’s function pointers.

4. Declarative Loop State Sugar (M4)
   - New YAML under `loop.state` to apply per‑iteration state updates on iteration context.
   - Operations:
     - `append`: list of { target: str, value: template_str }
     - `set`: list of { target: str, value: template_str }
     - `merge`: list of { target: str, value: template_str } (value must render to mapping)
   - Compiler generates `initial_input_mapper`, `iteration_input_mapper`, `loop_output_mapper` to enact this declaratively.

5. `agentic_loop` YAML Sugar (M5)
   - `kind: agentic_loop` compiles to the existing planner+executor `LoopStep` pattern (backed by `recipes.make_agentic_loop_pipeline`).
   - Minimal config surface; no new executor branching.

## 6) Detailed Design

### 6.1 Built‑in Transforms (M1)

- Location: `flujo/builtins.py` skill registry.
- Registration: `get_skill_registry().register()` with `side_effects=False`.
- Proposed signatures:

```python
async def to_csv(rows: list[dict[str, Any]], *, headers: list[str] | None = None) -> str
async def aggregate(
    data: list[dict[str, Any]], *, operation: Literal['sum','avg','count'], field: str | None = None
) -> float | int
async def select_fields(
    data: dict[str, Any] | list[dict[str, Any]], *, include: list[str] | None = None,
    rename: dict[str,str] | None = None
) -> dict[str, Any] | list[dict[str, Any]]
async def flatten(items: list[list[Any]]) -> list[Any]
```

- YAML usage examples:

```yaml
- kind: step
  name: csv
  uses: flujo.builtins:to_csv
  input: "{{ previous_step }}"

- kind: step
  name: total
  uses: flujo.builtins:aggregate
  input: { data: "{{ steps.get_data }}", operation: "sum", field: "price" }
```

- Telemetry: Mark as CPU‑only; no token/cost usage.

### 6.2 Template Filters (M2)

- Extend `AdvancedPromptFormatter` with deterministic, pure filters:
  - `|join(',')` for list[str]
  - `|upper`, `|lower` for str
  - `|length` for len(list|str|dict)
  - `|tojson` for JSON‑safe serialization
- Parser changes: keep current placeholder evaluation; add optional `|filter` suffix chain with a small map of filter functions.
- Safety: No evaluation of arbitrary code; filters operate only on the already‑resolved value. No side effects.
- Docs: Update `docs/creating_yaml.md` with filter reference and examples.

## 10) Progress & Milestones

- Completed: M1 — Built‑in Data Transforms
  - Implemented `to_csv`, `aggregate`, `select_fields`, `flatten` under `flujo.builtins.*`.
  - Unit/regression tests: `tests/unit/builtins/test_transforms.py` (passing in CI).
  - Documentation updated: Built‑in Data Transforms section added to `docs/creating_yaml.md`.
  - Docs CI + link checker added (`.github/workflows/docs.yml`), Make targets: `docs-build`, `docs-check`, `docs-ci`.
  - Typecheck/lint green; stabilized ConditionalStep branch span visibility under xdist in `executor_core` to keep integration test green.
  - PR: https://github.com/aandresalvarez/flujo/pull/428 (merged once all checks pass).

- Completed: M2 — Template Filters
  - Added support for `|join(',')`, `|upper`, `|lower`, `|length`, `|tojson` in `AdvancedPromptFormatter`.
  - Filter chain parsing respects quotes/parentheses; unknown filters raise explicit errors.
  - Unit tests: `tests/unit/prompting/test_filters.py` (covers happy paths, chaining, unknown filter errors, and list joining).
  - Docs: Added "Template Filters" section with examples in `docs/creating_yaml.md`.

- Completed: M3 — Expression strings (loader + evaluator)
  - Added `condition_expression` for conditional steps and `exit_expression` under `loop:`.
  - Safe evaluator with whitelisted AST (no calls/assignments); dotted access, subscripts, boolean ops, comparisons.
  - Loader compiles expressions into callables used by the DSL steps.
  - Unit tests: `tests/unit/blueprints/test_expression_conditions.py`.

- Completed: M4 — Declarative loop state sugar
  - Added support for `loop.state` with `append`/`set`/`merge` operations targeting `context.*` dotted paths.
  - Compiler generates identity mappers that apply state updates per-iteration while preserving control-flow semantics.
  - Unit tests: `tests/unit/blueprints/test_loop_state_sugar.py`.

- Completed: M5 — `agentic_loop` YAML sugar (compiler)
  - Added `kind: agentic_loop` to the blueprint compiler that wraps `recipes.make_agentic_loop_pipeline` as a single step.
  - Supports `planner` (agent import path) and `registry` (dict or import path) fields.
  - Unit test: `tests/unit/blueprints/test_agentic_loop_sugar.py`.

Open follow-ups:
- Add broader parity/e2e tests mirroring `tests/e2e/test_golden_transcript_agentic_loop.py` for the YAML sugar path.

### 6.3 Expressions for Conditions (M3)

- Schema additions (backward‑compatible):
  - Conditional step: `condition_expression: str` (optional; mutually exclusive with `condition`)
  - Loop step: `exit_expression: str` (optional; mutually exclusive with `exit_condition`)
- Loader (`domain/blueprint/loader.py`):
  - If `*_expression` is present, compile expression to a `Callable[[Any, Optional[Context]], Any]` using a sandboxed evaluator.
  - Expose variables: `previous_step` (value), `context` (TemplateContextProxy), `steps` (prior outputs map), and `output` alias to the previous step.
  - Result coercion: for conditional, branch key = expression result; for loop, exit when expression evaluates truthy.
- Evaluator:
  - Whitelisted AST nodes: `BoolOp`, `Compare`, `UnaryOp(not)`, `Name`, `Attribute`, `Subscript` (for `['key']`), `Constant`, and simple `In`/`NotIn`.
  - No calls, assignments, comprehensions, lambdas, or attribute writes.
  - Strict timeboxing not required (tiny strings), but guard recursion and size.
- Telemetry: Annotate span metadata with `evaluated_expression` and `evaluated_value`; never include sensitive data beyond what is already present in context/output.

### 6.4 Declarative Loop State (M4)

- YAML schema (inside `loop:`):

```yaml
loop:
  body: [...]
  max_loops: 10
  exit_expression: "previous_step.output.action == 'finish'"  # or exit_condition
  state:
    append:
      - target: "context.scratchpad.history"
        value: "User: {{ steps.ask_user.output }}"
      - target: "context.scratchpad.history"
        value: "AI: {{ steps.plan_question.output }}"
    set:
      - target: "context.summary"
        value: "{{ steps.summarize.output }}"
    merge:
      - target: "context.metrics"
        value: "{{ steps.collect_metrics.output }}"
```

- Compilation strategy:
  - Build three small Python closures (mappers) that:
    - Render template values with `TemplateContextProxy` (no Jinja). Filters from M2 may apply if present.
    - Apply operations on the isolated iteration context only.
  - Preserve idempotency: if iteration errors or pauses, global context is not mutated by the mapper side‑effects; merge occurs only on successful completion by policy.
  - Control‑flow preservation: mappers NEVER swallow `PausedException` or other orchestration exceptions.

### 6.5 `agentic_loop` YAML Sugar (M5)

- YAML schema:

```yaml
- kind: agentic_loop
  name: clarification_loop
  planner: "agents.clarifier"          # or import path
  registry: "agents.registry"          # or dict path; optional
  max_loops: 10
  exit_expression: "previous_step.output.action == 'finish'"  # optional
  output_template: "{{ previous_step.output.final_answer }}"   # optional
```

- Compiler behavior:
  - Resolve `planner` and `registry` to callables/agents.
  - Internally construct a `LoopStep` equivalent to `recipes.make_agentic_loop_pipeline` with mapper hooks as needed.
  - If `output_template` provided, emit a `loop_output_mapper` to render the final value.
- No executor core changes; this is purely compiler sugar.

## 7) Configuration & Security

- `flujo.toml` additions (read via `infra.config_manager`):
  - `blueprint.enable_expressions` (bool, default true)
  - `blueprint.allowed_imports` (list[str]) – already supported; ensure used for any new imports.
  - `blueprint.enabled_filters` (list[str]) with defaults [join, upper, lower, length, tojson]
- Security: Expression evaluator forbids calls, attribute writes, and arbitrary names. Template filters are pure and deterministic.

## 8) Telemetry & Observability

- Conditional policy: already sets `executed_branch_key`; add optional `evaluated_expression` and `evaluated_value` when expression path used.
- Loop policy: attach `loop_iteration` and optionally `evaluated_exit_expression` per iteration when available.
- Built‑ins: mark as CPU‑only; ensure usage/tokens remain zeroed.

## 9) Backward Compatibility

- All new keys are optional; existing `condition` (callable) and `exit_condition` continue to work.
- No behavior changes to policies; HITL pause behavior remains intact.
- YAML that uses new filters will require M2; otherwise templates behave as today.

## 10) Testing Strategy

- Unit tests:
  - `tests/unit/blueprint/test_expressions.py`: truthiness, comparisons, `in`, dotted paths, guardrails, error messages.
  - `tests/unit/prompting/test_filters.py`: join/upper/lower/length/tojson behavior and escaping.
  - `tests/unit/builtins/test_transforms.py`: to_csv/aggregate/select_fields/flatten happy‑paths and edge cases.
  - `tests/unit/blueprint/test_loop_state.py`: append/set/merge across iterations; idempotency on retry; pause propagation.
- Integration tests:
  - `tests/integration/blueprint/test_conditional_expression.yaml`: ensure branches execute and metadata shows evaluated result.
  - `tests/integration/blueprint/test_loop_state_expression.yaml`: conversational loop with state history built declaratively.
- E2E:
  - Mirror `tests/e2e/test_golden_transcript_agentic_loop.py` using new `kind: agentic_loop` YAML sugar.

## 11) Rollout Plan (Milestones)

- M1: Built‑in transforms
  - Code: `flujo/builtins.py`
  - Docs: Examples in `docs/blueprints_yaml.md`
  - Criteria: All unit tests for transforms pass; examples runnable via CLI.

- M2: Template filters
  - Code: `flujo/utils/prompting.py`
  - Docs: Filter reference + examples
  - Criteria: Filter unit tests pass; no regressions in existing templating tests.

- M3: Expressions for conditions
  - Code: `domain/blueprint/loader.py` (+ evaluator module), telemetry annotations in conditional policy
  - Docs: Add section on expressions; safety notes
  - Criteria: Expression tests (unit + integration) pass; failure messages are clear; `make all` green.

- M4: Loop state sugar
  - Code: `domain/blueprint/loader.py` (mapper synthesis), docs/examples
  - Criteria: Loop state tests pass; idempotency and pause propagation validated.

- M5: `agentic_loop` sugar
  - Code: `domain/blueprint/loader.py` (compiler path), reuse `recipes.make_agentic_loop_pipeline`
  - Docs: Conversational loop template; `flujo create` integration example
  - Criteria: E2E passes; parity with recipe‑based pipeline.

## 12) Risks & Mitigations

- Risk: Expression evaluator grows unsafe/complex.
  - Mitigation: Keep a minimal AST whitelist; fuzz tests; no function calls; config toggle to disable.
- Risk: Loop state sugar mutates global context on failure.
  - Mitigation: Apply on isolated iteration context; rely on existing policy merge on success only; add tests.
- Risk: Templating filters surprise users (Jinja expectations).
  - Mitigation: Document supported subset clearly; explicit errors on unknown filters.
- Risk: Scope creep into executor core.
  - Mitigation: Enforce compiler‑only approach and policy registration; code review checklist includes non‑negotiables.

## 13) Developer Tasks (by Milestone)

- M1
  - [ ] Implement transforms in `flujo/builtins.py` + tests
  - [ ] Update docs and examples

- M2
  - [ ] Add filters to `AdvancedPromptFormatter` + tests
  - [ ] Doc updates

- M3
  - [ ] Implement safe expression evaluator + loader glue
  - [ ] Add telemetry annotations
  - [ ] Tests (unit + integration) and docs

- M4
  - [ ] Add `loop.state` schema + mapper generation
  - [ ] Tests; docs with conversational examples

- M5
  - [ ] Add `kind: agentic_loop` compiler sugar
  - [ ] E2E parity tests; docs; `flujo create` recipe sample

## 14) Documentation Updates

- `docs/blueprints_yaml.md`:
  - New sections: Transforms, Filters, Expressions, Loop State, Agentic Loop.
- `README.md` and CLI help: brief pointers to new features.
- Examples in `examples/` showcasing each feature.

## 15) Acceptance Criteria (Summary)

- `make all` passes with new tests.
- Generated YAMLs for typical scenarios run without custom Python glue.
- Telemetry clearly displays branch decisions and loop iteration exits when expressions are used.
- HITL pause/resume behavior remains correct in loops under new sugar.
- No executor core regressions; policies untouched except telemetry annotations.
