---
description: From first principles, any non-trivial intelligent task is not a single, monolithic action but a computational graph—a sequence of distinct operations where the output of one step often becomes the input for another. The fundamental challenges of building such a system, especially with AI components, are managing its state, unreliability, control flow, and resource consumption. Flujo is a framework architected to provide the essential primitives to solve these core problems directly. The Atomic Unit of Work (The Step): The first principle is that any operation, whether it's an AI model call, a database query, or a simple data transformation, can be encapsulated as an atomic Step. This abstraction provides a standardized interface for any piece of logic, making it modular, reusable, and independently testable. Flujo recognizes that not all steps are AI; it treats both deterministic code and probabilistic model calls as first-class citizens in the same graph. Information Flow and Memory (The PipelineContext): Steps in a graph are rarely independent; they need to share information. Flujo addresses this by providing a PipelineContext, an explicit, persistent state object that is passed through the entire execution graph. This serves as the workflow's memory, allowing steps to communicate, accumulate results, and make decisions based on a shared understanding of the world, solving the fundamental problem of state management in a distributed process. Inherent Unreliability (Resilience Primitives): AI model calls and network requests are inherently unreliable—they can fail, time out, or return malformed data. Instead of forcing developers to write boilerplate error-handling for every operation, Flujo builds resilience primitives directly into the Step abstraction. Features like automatic retries with exponential backoff and declarative fallbacks to alternative steps are the framework's solution to managing this unreliability systematically. Complex Processes (Control Flow): Real-world processes are not always linear. They require decision-making and iteration. Flujo provides explicit control flow constructs to build sophisticated graphs. ConditionalStep (branch_on) acts as a routing mechanism to direct the flow based on runtime data, while LoopStep (loop_until) enables iterative refinement and polling. These primitives allow developers to model complex business logic directly in the workflow's structure. Finite Resources (The UsageGovernor): Every computational step, especially an AI call, consumes resources—time, money (tokens), and processing power. A system without constraints is a liability. Flujo's UsageGovernor is the explicit solution to this problem, providing a governance layer that tracks cumulative costs and token counts. It acts as a safety circuit, halting execution proactively before a budget is exceeded, thus making AI workflows economically predictable and safe to run in production. Opacity and Debugging (Observability): A complex, running graph can become a "black box," impossible to debug when it fails. Flujo addresses this fundamental problem of opacity by making observability a core, non-negotiable feature. Through structured persistence to a local SQLiteBackend and inspection tools like the flujo lens CLI, it captures a complete, hierarchical trace of every step's execution—inputs, outputs, timings, and state changes—making the entire process transparent and debuggable from first principles. In essence, Flujo is a framework for architecting and operating intelligent systems by providing a robust, type-safe toolkit to define, connect, and manage the inherently unreliable, stateful, and resource-intensive computational steps that constitute any complex AI-driven process.
alwaysApply: true
---
