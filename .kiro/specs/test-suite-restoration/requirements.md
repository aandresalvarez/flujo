 

# Architectural Refinement Requirements for Flujo (Phase 2)

## Introduction

Following the initial stabilization phase, this document outlines the next set of architectural requirements to address the more nuanced inconsistencies identified in the Flujo **Execution Core**. The framework's foundational stability has improved, but key areas related to failure domain semantics, state propagation at recursive boundaries, and observability require refinement to fully align the implementation with the architectural design.

---

### **REQ-STATE-002: Consistent State Propagation at Recursive Boundaries**

*   **Statement:** The state and output of any nested execution must be correctly and consistently propagated to the parent `Step`. Specifically, a `LoopStep` must invoke its `loop_output_mapper` upon termination, regardless of whether it exits via its `exit_condition_callable` or by reaching `max_loops`, to ensure its final output is correctly transformed.

*   **Rationale:** Test failures show that the `LoopStep` handler fails to apply its output mapper when exiting due to `max_loops`. This violates the architectural principle that higher-order steps should have a predictable and consistent interface. The final output of a `LoopStep` must always be the result of its defined mapping logic, not an internal state artifact. This requirement ensures the `LoopStep`'s contract is honored in all termination scenarios.

### **REQ-CONTEXT-002: Guaranteed Context Integrity for Dynamic and Composed Steps**

*   **Statement:** Context modifications originating from dynamically generated or internally composed steps (e.g., the temporary `ParallelStep` within a `DynamicParallelRouterStep`) must be correctly merged back into the main pipeline context. The context management logic must be functionally correct and performant under load.

*   **Rationale:** The principle of algebraic closure requires that all `Step` variants, including dynamic ones, interact with the pipeline context predictably. Failures in `DynamicParallelRouterStep` indicate that while the core `ParallelStep` context merging may be fixed, the results are not being propagated from the temporary, internal parallel execution. Furthermore, performance-related failures under load suggest that the current context merge implementation is not efficient enough for production scenarios, violating a key performance pillar of the architecture.

### **REQ-FAILURE-002: Consistent and Unambiguous Failure Domain Semantics**

*   **Statement:** The `ExecutorCore` must enforce a clear and consistent policy for handling failures from different domains. `Validator` failures must be treated as terminal for a given attempt and must *not* trigger a retry of the agent. `Plugin` failures within a `LoopStep` must be correctly contextualized in the loop's final feedback message.

*   **Rationale:** The current implementation exhibits contradictory behavior, and the test suite reflects this ambiguity. A `Validator`'s role is to gatekeep an already-produced output; retrying the agent based on its failure is architecturally incorrect and inefficient. Separately, when a `LoopStep` fails due to an internal component (like a plugin), the feedback must be clear about the source of the failure to maintain observability. This requirement enforces strict, predictable semantics for different failure types.

### **REQ-OBSERVABILITY-001: End-to-End Trace Persistence**

*   **Statement:** The full, hierarchical execution trace generated by the in-memory `TraceManager` must be reliably persisted to the configured `StateBackend` upon the completion of every pipeline run. The system must provide a mechanism to retrieve this persisted trace for operational inspection.

*   **Rationale:** The observability pillar of the Flujo architecture is incomplete if trace data is lost at the end of a run. The `flujo lens trace` CLI tool and other operational diagnostics depend on the successful persistence of this data. This requirement closes the loop between in-memory trace generation and durable storage, making the system's observability features fully functional.

