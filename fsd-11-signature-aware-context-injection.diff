diff --git a/docs/specs/FSD-11.md b/docs/specs/FSD-11.md
new file mode 100644
index 0000000..41d90e6
--- /dev/null
+++ b/docs/specs/FSD-11.md
@@ -0,0 +1,192 @@
+# Functional Specification Document: FSD-11
+
+**Title:** Signature-Aware Context Injection for Agent Execution
+**Author:** Alvaro Alvarez (as per user feedback)
+**Status:** Approved for Implementation
+**Priority:** P1 - Critical
+**Date:** July 23, 2025
+**Version:** 1.1
+
+---
+
+## 1. Overview
+
+This document specifies a critical bug fix for the Flujo framework's core execution logic. Currently, the `Flujo` runner attempts to inject a `pipeline_context` object into every agent's `run` method, regardless of its signature. This causes a `TypeError` for any simple, stateless agent created with the standard `make_agent_async` factory, as the underlying Pydantic-AI agent does not accept a `context` keyword argument. This bug makes the most basic and common use case of the framework fail.
+
+The proposed solution is to make the context injection mechanism **signature-aware**. The runner will inspect the target agent's `run` method before execution. It will only inject the `context` object if the method signature explicitly includes a `context` parameter or a variable keyword argument (`**kwargs`). This change will make simple, stateless agents work out-of-the-box, significantly improving the new user experience while maintaining full functionality for advanced, context-aware agents.
+
+Additionally, error reporting for step failures will be enhanced to expose the original underlying exception, dramatically improving debuggability.
+
+## 2. Problem Statement
+
+A developer attempting to run a minimal pipeline with a standard, stateless Flujo agent encounters an immediate and non-obvious failure.
+
+**Scenario:** A developer defines a simple agent using the recommended `flujo.infra.agents.make_agent_async` factory. This agent is intended to be stateless and therefore does not have a `context` parameter in its logic.
+
+```python
+# The CORRECT way to create a stateless agent in Flujo
+from flujo.infra.agents import make_agent_async
+
+stateless_agent = make_agent_async(
+    model="openai:gpt-4o",
+    system_prompt="You are a helpful assistant.",
+    output_type=str
+)
+
+# This agent is an AsyncAgentWrapper. Its `run` method passes arguments
+# down to an internal Pydantic-AI agent, which does NOT accept a 'context' argument.
+```
+
+When this standard, stateless agent is used in a Flujo pipeline, the `Flujo` runner attempts to call the wrapper's `run` method with a `context` argument (`agent.run(data, context=...)`). The wrapper then passes this unexpected `context` argument down to the internal Pydantic-AI agent, which correctly rejects it. This results in a `TypeError`, which is then hidden by Flujo's current error handling.
+
+**Current Erroneous Behavior:**
+
+1. User creates a simple, stateless agent using the standard `make_agent_async` factory.
+2. The `Flujo` runner unconditionally injects the `context` object when it calls the agent wrapper.
+3. The agent call fails with `TypeError: run() got an unexpected keyword argument 'context'`.
+4. Flujo's runner reports a vague failure like `Step 'MyStep' failed.` without exposing the underlying `TypeError`.
+
+This behavior is incorrect because it prevents the most fundamental use case from working as expected and makes debugging unnecessarily difficult. It forces new users to immediately learn about and implement context-aware patterns for even the simplest tasks.
+
+## 3. Functional Requirements (FR)
+
+| ID | Requirement | Justification |
+| :--- | :--- | :--- |
+| **FR-35** | The Flujo step executor **SHALL** inspect the signature of an agent's `run` method before invoking it. | To determine if the agent can accept a `context` argument. |
+| **FR-35a** | The step executor **SHALL** pass the `context` object as a keyword argument **only if** the agent's `run` method signature contains either a parameter named `context` or a variable keyword parameter (`**kwargs`). | Corrects the core bug by preventing `TypeError` for stateless agents. |
+| **FR-35b** | The step executor **SHALL NOT** pass the `context` object if the agent's `run` method signature does not meet the criteria in FR-35a. | Ensures simple, stateless agents can be executed without modification. |
+| **FR-36** | When an agent execution fails within a step, the resulting `StepResult` object **SHALL** have its `feedback` attribute populated with the type and message of the original underlying exception. | Improves debuggability by exposing the root cause of failures, such as the `TypeError` described in the problem statement. |
+
+## 4. Non-Functional Requirements (NFR)
+
+| ID | Requirement | Justification |
+| :--- | :--- | :--- |
+| **NFR-13** | The signature inspection mechanism **MUST NOT** introduce a noticeable performance degradation. The overhead for a single step execution should be less than 1ms. | `inspect.signature()` can be slow. The implementation must include caching to ensure performance is maintained in high-throughput pipelines. |
+| **NFR-14** | Existing pipelines with correctly defined context-aware agents (e.g., those implementing `ContextAwareAgentProtocol`) **MUST** continue to function without any changes. | Ensures backward compatibility for users who have already adopted advanced patterns. |
+
+## 5. Technical Design & Specification
+
+The fix will be implemented by introducing a cached signature inspection utility and modifying the runner's invocation logic.
+
+### 5.1. Signature Inspection Helper
+
+A cached helper function will be created in `flujo/application/context_manager.py`.
+
+```python
+# In flujo/application/context_manager.py
+
+import inspect
+import weakref
+from typing import Callable, Any, Dict
+
+# Weak-keyed cache for hashable callables, ID-based for unhashable ones
+_accepts_param_cache_weak: weakref.WeakKeyDictionary[Callable, Dict[str, bool]] = weakref.WeakKeyDictionary()
+_accepts_param_cache_id: weakref.WeakValueDictionary[int, Dict[str, bool]] = weakref.WeakValueDictionary()
+
+def _accepts_param(func: Callable[..., Any], param: str) -> bool:
+    """
+    Check if a callable's signature includes `param` or `**kwargs`.
+    Results are cached for performance.
+    """
+    # ... (Implementation of cache lookup) ...
+
+    try:
+        sig = inspect.signature(func)
+        if param in sig.parameters:
+            result = True
+        elif any(p.kind == inspect.Parameter.VAR_KEYWORD for p in sig.parameters.values()):
+            result = True
+        else:
+            result = False
+    except (TypeError, ValueError):
+        # If signature cannot be determined, assume it doesn't accept the param
+        result = False
+
+    # ... (Implementation of cache storage) ...
+    return result
+```
+
+### 5.2. Runner Invocation Logic Modification
+
+The core change will be in `flujo/application/core/step_logic.py`, within the `_run_step_logic` function (or a helper it calls).
+
+**Current (Simplified) Logic:**
+```python
+agent_kwargs = {}
+if context is not None:
+    agent_kwargs["context"] = context # BUG: This is always added
+raw_output = await current_agent.run(data, **agent_kwargs)
+```
+
+**Proposed (Simplified) Logic:**
+```python
+from flujo.application.context_manager import _accepts_param
+
+agent_kwargs = {}
+# FR-35a & FR-35b: Use the helper to check the agent's signature
+if context is not None and _accepts_param(current_agent.run, "context"):
+    agent_kwargs["context"] = context
+
+# ... (add other kwargs like resources, temperature similarly) ...
+raw_output = await current_agent.run(data, **agent_kwargs)
+```
+
+### 5.3. Enhanced Error Reporting
+
+The `try...except` block surrounding the agent call in `_run_step_logic` will be modified.
+
+**Current (Simplified) Logic:**
+```python
+try:
+    # agent call
+except Exception as e:
+    result.feedback = "Step failed." # Hides the real error
+```
+
+**Proposed (Simplified) Logic:**
+```python
+try:
+    # agent call
+except Exception as e:
+    # FR-36: Populate feedback with the actual error type and message
+    result.feedback = f"Agent execution failed with {type(e).__name__}: {e}"
+```
+
+## 6. API Changes
+
+None. This is a behavioral bug fix that makes the existing API function as users would intuitively expect. The user-facing API of `make_agent_async`, `Step`, `Pipeline`, and `Flujo` remains unchanged.
+
+## 7. Testing Plan
+
+A new integration test file (`tests/integration/test_context_injection.py`) will be created to validate the fix and prevent regressions.
+
+* **Test Case 1: Stateless Agent (`make_agent_async`)**
+  * **Given:** A pipeline with a `Step` using an agent created via `make_agent_async` that is stateless.
+  * **When:** The pipeline is executed by the `Flujo` runner with a context model configured.
+  * **Then:** The pipeline completes successfully, and no `TypeError` is raised. The `context` is **not** passed to the agent.
+
+* **Test Case 2: Context-Aware Agent (Explicit `context` Param)**
+  * **Given:** A pipeline with a `Step` using a custom agent class with `def run(self, data: str, *, context: MyContext)`.
+  * **When:** The pipeline is executed with a `context_model`.
+  * **Then:** The pipeline completes successfully, and the agent correctly receives and can modify the context.
+
+* **Test Case 3: Context-Aware Agent (`**kwargs`)**
+  * **Given:** A pipeline with a `Step` using an agent with `def run(self, data: str, **kwargs)`.
+  * **When:** The pipeline is executed with a `context_model`.
+  * **Then:** The pipeline completes successfully, and the agent correctly receives the context within its `kwargs`.
+
+* **Test Case 4: Error Propagation**
+  * **Given:** A pipeline with an agent that is designed to fail for a reason *other than* a signature mismatch (e.g., raises `ValueError("Internal error")`).
+  * **When:** The pipeline is executed.
+  * **Then:** The final `StepResult.feedback` string **must** contain the substring `"ValueError: Internal error"`.
+
+## 8. Risks and Mitigation
+
+| Risk | Impact | Mitigation |
+| :--- | :--- | :--- |
+| Performance degradation from repeated signature inspection. | Medium | This is mitigated by implementing a robust caching mechanism for the signature check results (NFR-13). |
+| Some users may have worked around the bug by adding unused `**kwargs` to their agents. | Low | This fix will not break their code. Their agents will continue to receive the context. This is considered an improvement in correctness and is non-breaking. |
+
+## 9. Backward Compatibility
+
+This change is a bug fix that improves backward compatibility. Code that previously failed due to this issue will now work as expected. Code that was written to be context-aware (by correctly including a `context` or `**kwargs` parameter) will continue to work correctly (NFR-14). There are no breaking changes for correctly implemented pipelines.
diff --git a/flujo/application/context_manager.py b/flujo/application/context_manager.py
index ff14be3..c7d799f 100644
--- a/flujo/application/context_manager.py
+++ b/flujo/application/context_manager.py
@@ -14,6 +14,7 @@ __all__ = [
     "_get_validation_flags",
     "_apply_validation_metadata",
     "_types_compatible",
+    "_should_pass_context",
 ]

 _accepts_param_cache_weak: weakref.WeakKeyDictionary[
@@ -59,7 +60,17 @@ def _accepts_param(func: Callable[..., Any], param: str) -> Optional[bool]:
         if param in sig.parameters:
             result = True
         elif any(p.kind == inspect.Parameter.VAR_KEYWORD for p in sig.parameters.values()):
-            result = True
+            # Check if the **kwargs parameter is typed as 'Never' (doesn't accept any kwargs)
+            for p in sig.parameters.values():
+                if p.kind == inspect.Parameter.VAR_KEYWORD:
+                    # If the **kwargs parameter is annotated as 'Never', it doesn't accept any parameters
+                    if str(p.annotation) == "Never":
+                        result = False
+                    else:
+                        result = True
+                    break
+            else:
+                result = True
         else:
             result = False
     except (TypeError, ValueError):
@@ -83,6 +94,23 @@ def _extract_missing_fields(cause: Any) -> list[str]:
     return missing_fields


+def _should_pass_context(spec: Any, context: Optional[Any], func: Callable[..., Any]) -> bool:
+    """Determine if context should be passed to a function based on signature analysis.
+
+    Args:
+        spec: Signature analysis result from analyze_signature()
+        context: The context object to potentially pass
+        func: The function to analyze
+
+    Returns:
+        True if context should be passed to the function, False otherwise
+    """
+    # Check if function accepts context parameter (either explicitly or via **kwargs)
+    # This is different from spec.needs_context which only checks if context is required
+    accepts_context = _accepts_param(func, "context")
+    return spec.needs_context or (context is not None and bool(accepts_context))
+
+
 def _types_compatible(a: Any, b: Any) -> bool:
     """Return ``True`` if type ``a`` is compatible with type ``b``."""
     # If a is a value, get its type
diff --git a/flujo/application/core/step_logic.py b/flujo/application/core/step_logic.py
index 1f3d105..e2f1a47 100644
--- a/flujo/application/core/step_logic.py
+++ b/flujo/application/core/step_logic.py
@@ -1352,11 +1352,8 @@ async def _run_step_logic(
             func = cast(Callable[..., Any], func)
             spec = analyze_signature(func)

-            if spec.needs_context:
-                if context is None:
-                    raise TypeError(
-                        f"Component in step '{step.name}' requires a context, but no context model was provided to the Flujo runner."
-                    )
+            # FR-35a & FR-35b: Use signature-aware context injection
+            if _should_pass_context(spec, context, func):
                 agent_kwargs["context"] = context

             if resources is not None:
@@ -1609,7 +1606,10 @@ async def _run_step_logic(
     if accumulated_feedbacks:
         result.feedback = "\n".join(accumulated_feedbacks).strip()
     else:
-        result.feedback = str(last_exception)
+        # FR-36: Populate feedback with the actual error type and message
+        result.feedback = (
+            f"Agent execution failed with {type(last_exception).__name__}: {last_exception}"
+        )
     result.attempts = step.config.max_retries
     result.latency_s = 0.0

diff --git a/flujo/application/core/ultra_executor.py b/flujo/application/core/ultra_executor.py
index f8622f8..443a087 100644
--- a/flujo/application/core/ultra_executor.py
+++ b/flujo/application/core/ultra_executor.py
@@ -380,20 +380,30 @@ class UltraStepExecutor(Generic[TContext]):
                 start_time = time.perf_counter()  # Track execution time
                 last_exception: Exception = Exception("Unknown error")
                 for attempt in range(1, step.config.max_retries + 1):
-                    # Build agent kwargs
-                    kwargs = {}
-                    if context is not None:
-                        kwargs["context"] = context
-                    if resources is not None:
-                        kwargs["resources"] = resources
-                    if step.config.temperature is not None:
-                        kwargs["temperature"] = step.config.temperature
-                    if breach_event is not None:
-                        kwargs["breach_event"] = breach_event
-
                     run_func = getattr(agent, "run", None)
                     is_mock = isinstance(run_func, (Mock, MagicMock, AsyncMock))

+                    # Build filtered kwargs based on what the function accepts
+                    def build_filtered_kwargs(func: Any) -> dict[str, Any]:
+                        filtered_kwargs: dict[str, Any] = {}
+                        if func is not None:
+                            from ..context_manager import _accepts_param
+                            from ...signature_tools import analyze_signature
+                            from ..context_manager import _should_pass_context
+
+                            spec = analyze_signature(func)
+                            if _should_pass_context(spec, context, func):
+                                filtered_kwargs["context"] = context
+                            if resources is not None and _accepts_param(func, "resources"):
+                                filtered_kwargs["resources"] = resources
+                            if step.config.temperature is not None and _accepts_param(
+                                func, "temperature"
+                            ):
+                                filtered_kwargs["temperature"] = step.config.temperature
+                            if breach_event is not None and _accepts_param(func, "breach_event"):
+                                filtered_kwargs["breach_event"] = breach_event
+                        return filtered_kwargs
+
                     try:
                         # Process input data through prompt processors
                         processed_data = data
@@ -430,7 +440,10 @@ class UltraStepExecutor(Generic[TContext]):
                         try:
                             if stream and hasattr(agent, "stream"):
                                 chunks = []
-                                async for chunk in agent.stream(processed_data, **kwargs):
+                                stream_kwargs = build_filtered_kwargs(
+                                    getattr(agent, "stream", None)
+                                )
+                                async for chunk in agent.stream(processed_data, **stream_kwargs):
                                     if on_chunk:
                                         await on_chunk(chunk)
                                     chunks.append(chunk)
@@ -445,41 +458,20 @@ class UltraStepExecutor(Generic[TContext]):
                                 if is_mock:
                                     if run_func is None:
                                         raise RuntimeError("Agent has no run method")
-                                    raw = await run_func(processed_data, **kwargs)
+                                    mock_kwargs = build_filtered_kwargs(run_func)
+                                    raw = await run_func(processed_data, **mock_kwargs)
                                 else:
                                     try:
                                         if run_func is not None:
-                                            # Use proper parameter detection like step_logic.py
-                                            from ..context_manager import _accepts_param
-
-                                            # Build kwargs based on what the function accepts
-                                            filtered_kwargs = {}
-                                            if context is not None and _accepts_param(
-                                                run_func, "context"
-                                            ):
-                                                filtered_kwargs["context"] = context
-                                            if resources is not None and _accepts_param(
-                                                run_func, "resources"
-                                            ):
-                                                filtered_kwargs["resources"] = resources
-                                            if (
-                                                step.config.temperature is not None
-                                                and _accepts_param(run_func, "temperature")
-                                            ):
-                                                filtered_kwargs["temperature"] = (
-                                                    step.config.temperature
-                                                )
-                                            if breach_event is not None and _accepts_param(
-                                                run_func, "breach_event"
-                                            ):
-                                                filtered_kwargs["breach_event"] = breach_event
-
+                                            filtered_kwargs = build_filtered_kwargs(run_func)
                                             raw = await run_func(processed_data, **filtered_kwargs)
                                         else:
                                             raise RuntimeError("Agent has no run method")
                                     except Exception:
                                         if run_func is not None:
-                                            raw = await run_func(processed_data, **kwargs)
+                                            # Fallback to filtered kwargs for backward compatibility
+                                            fallback_kwargs = build_filtered_kwargs(run_func)
+                                            raw = await run_func(processed_data, **fallback_kwargs)
                                         else:
                                             raise RuntimeError("Agent has no run method")
                         except Exception:
@@ -594,7 +586,7 @@ class UltraStepExecutor(Generic[TContext]):
                         output=None,
                         success=False,
                         attempts=attempt,
-                        feedback=str(last_exception),
+                        feedback=f"Agent execution failed with {type(last_exception).__name__}: {last_exception}",
                         latency_s=0.0,
                     )
                 else:
diff --git a/flujo/infra/agents.py b/flujo/infra/agents.py
index 51b46f5..0b322c4 100755
--- a/flujo/infra/agents.py
+++ b/flujo/infra/agents.py
@@ -196,9 +196,21 @@ class AsyncAgentWrapper(Generic[AgentInT, AgentOutT], AsyncAgentProtocol[AgentIn
             arg.model_dump() if isinstance(arg, PydanticBaseModel) else arg
             for arg in processed_args
         ]
+        # Filter kwargs before processing to avoid passing unwanted parameters
+        from flujo.application.context_manager import _accepts_param
+
+        filtered_kwargs = {}
+        for key, value in kwargs.items():
+            if key in ["context", "pipeline_context"]:
+                # Only pass context if the underlying agent accepts it
+                if _accepts_param(self._agent.run, "context"):
+                    filtered_kwargs[key] = value
+            else:
+                filtered_kwargs[key] = value
+
         processed_kwargs = {
             key: value.model_dump() if isinstance(value, PydanticBaseModel) else value
-            for key, value in kwargs.items()
+            for key, value in filtered_kwargs.items()
         }

         retryer = AsyncRetrying(
diff --git a/tests/integration/test_context_injection.py b/tests/integration/test_context_injection.py
new file mode 100644
index 0000000..c402a41
--- /dev/null
+++ b/tests/integration/test_context_injection.py
@@ -0,0 +1,338 @@
+"""Integration tests for FSD-11: Signature-Aware Context Injection for Agent Execution.
+
+This test file validates the fix for the critical bug where stateless agents created
+with make_agent_async would fail with TypeError due to unconditional context injection.
+"""
+
+import pytest
+from unittest.mock import AsyncMock
+from flujo.domain.dsl import Pipeline, Step, StepConfig
+from flujo.domain.models import PipelineContext
+from flujo.infra.agents import make_agent_async
+from tests.conftest import create_test_flujo
+
+
+def get_step_result(pipeline_result):
+    """Helper function to get the first step result from a pipeline result."""
+    assert len(pipeline_result.step_history) > 0
+    return pipeline_result.step_history[0]
+
+
+class StatelessAgent:
+    """Mock stateless agent that does NOT accept context parameter."""
+
+    def __init__(self):
+        self.run_mock = AsyncMock(return_value={"output": "stateless response"})
+
+    async def run(self, data: str) -> dict:
+        """Run method that does NOT accept context parameter."""
+        await self.run_mock(data)
+        return {"output": f"Stateless processed: {data}"}
+
+
+class ContextAwareAgent:
+    """Mock context-aware agent that explicitly accepts context parameter."""
+
+    def __init__(self):
+        self.run_mock = AsyncMock(return_value={"output": "context-aware response"})
+
+    async def run(self, data: str, *, context: PipelineContext) -> dict:
+        """Run method that explicitly accepts context parameter."""
+        await self.run_mock(data, context=context)
+        return {"output": f"Context-aware processed: {data}", "context_received": True}
+
+
+class KwargsAgent:
+    """Mock agent that accepts **kwargs (should receive context)."""
+
+    def __init__(self):
+        self.run_mock = AsyncMock(return_value={"output": "kwargs response"})
+
+    async def run(self, data: str, **kwargs) -> dict:
+        """Run method that accepts **kwargs."""
+        await self.run_mock(data, **kwargs)
+        return {"output": f"Kwargs processed: {data}", "kwargs_received": "context" in kwargs}
+
+
+class FailingAgent:
+    """Mock agent that raises a specific error for testing error propagation."""
+
+    async def run(self, data: str) -> dict:
+        """Run method that raises a specific error."""
+        raise ValueError("Internal error")
+
+
+@pytest.mark.asyncio
+async def test_stateless_agent_no_context_injection():
+    """Test Case 1: Stateless Agent (make_agent_async)
+
+    Given: A pipeline with a Step using an agent created via make_agent_async that is stateless.
+    When: The pipeline is executed by the Flujo runner with a context model configured.
+    Then: The pipeline completes successfully, and no TypeError is raised. The context is NOT passed to the agent.
+    """
+    # Create a stateless agent using make_agent_async
+    stateless_agent = make_agent_async(
+        model="openai:gpt-4o", system_prompt="You are a helpful assistant.", output_type=str
+    )
+
+    step = Step.model_validate(
+        {
+            "name": "stateless_step",
+            "agent": stateless_agent,
+            "config": StepConfig(max_retries=1, timeout_s=30),
+        }
+    )
+
+    pipeline = Pipeline(steps=[step])
+    flujo = create_test_flujo(pipeline, context_model=PipelineContext)
+
+    # Run the pipeline - this should NOT raise TypeError
+    async for result in flujo.run_async(
+        "test_data", initial_context_data={"initial_prompt": "test prompt"}
+    ):
+        pass
+
+    # Verify the step succeeded
+    step_result = get_step_result(result)
+    assert step_result.success
+    assert step_result.feedback is None
+
+
+@pytest.mark.asyncio
+async def test_stateless_agent_custom_no_context_injection():
+    """Test Case 1b: Custom Stateless Agent
+
+    Given: A pipeline with a Step using a custom stateless agent.
+    When: The pipeline is executed with a context model.
+    Then: The pipeline completes successfully, and no TypeError is raised.
+    """
+    stateless_agent = StatelessAgent()
+
+    step = Step.model_validate(
+        {
+            "name": "custom_stateless_step",
+            "agent": stateless_agent,
+            "config": StepConfig(max_retries=1, timeout_s=30),
+        }
+    )
+
+    pipeline = Pipeline(steps=[step])
+    flujo = create_test_flujo(pipeline, context_model=PipelineContext)
+
+    # Run the pipeline - this should NOT raise TypeError
+    async for result in flujo.run_async(
+        "test_data", initial_context_data={"initial_prompt": "test prompt"}
+    ):
+        pass
+
+    # Verify the step succeeded
+    step_result = get_step_result(result)
+    assert step_result.success
+    assert step_result.feedback is None
+
+    # Verify the agent was called without context parameter
+    stateless_agent.run_mock.assert_called_once()
+    call_args = stateless_agent.run_mock.call_args
+    assert "context" not in call_args[1]  # No context parameter passed
+
+
+@pytest.mark.asyncio
+async def test_context_aware_agent_explicit_context():
+    """Test Case 2: Context-Aware Agent (Explicit context Param)
+
+    Given: A pipeline with a Step using a custom agent class with explicit context parameter.
+    When: The pipeline is executed with a context_model.
+    Then: The pipeline completes successfully, and the agent correctly receives and can modify the context.
+    """
+    context_aware_agent = ContextAwareAgent()
+
+    step = Step.model_validate(
+        {
+            "name": "context_aware_step",
+            "agent": context_aware_agent,
+            "config": StepConfig(max_retries=1, timeout_s=30),
+        }
+    )
+
+    pipeline = Pipeline(steps=[step])
+    flujo = create_test_flujo(pipeline, context_model=PipelineContext)
+
+    # Run the pipeline
+    async for result in flujo.run_async(
+        "test_data", initial_context_data={"initial_prompt": "test prompt"}
+    ):
+        pass
+
+    # Verify the step succeeded
+    step_result = get_step_result(result)
+    assert step_result.success
+    assert step_result.feedback is None
+
+    # Verify the agent was called with context parameter
+    context_aware_agent.run_mock.assert_called_once()
+    call_args = context_aware_agent.run_mock.call_args
+    assert "context" in call_args[1]
+    assert call_args[1]["context"].initial_prompt == "test prompt"
+
+
+@pytest.mark.asyncio
+async def test_context_aware_agent_kwargs():
+    """Test Case 3: Context-Aware Agent (**kwargs)
+
+    Given: A pipeline with a Step using an agent with **kwargs.
+    When: The pipeline is executed with a context_model.
+    Then: The pipeline completes successfully, and the agent correctly receives the context within its kwargs.
+    """
+    kwargs_agent = KwargsAgent()
+
+    step = Step.model_validate(
+        {
+            "name": "kwargs_step",
+            "agent": kwargs_agent,
+            "config": StepConfig(max_retries=1, timeout_s=30),
+        }
+    )
+
+    pipeline = Pipeline(steps=[step])
+    flujo = create_test_flujo(pipeline, context_model=PipelineContext)
+
+    # Run the pipeline
+    async for result in flujo.run_async(
+        "test_data", initial_context_data={"initial_prompt": "test prompt"}
+    ):
+        pass
+
+    # Verify the step succeeded
+    step_result = get_step_result(result)
+    assert step_result.success
+    assert step_result.feedback is None
+
+    # Verify the agent was called with context in kwargs
+    kwargs_agent.run_mock.assert_called_once()
+    call_args = kwargs_agent.run_mock.call_args
+    assert "context" in call_args[1]
+    assert call_args[1]["context"].initial_prompt == "test prompt"
+
+
+@pytest.mark.asyncio
+async def test_error_propagation():
+    """Test Case 4: Error Propagation
+
+    Given: A pipeline with an agent that is designed to fail for a reason other than a signature mismatch.
+    When: The pipeline is executed.
+    Then: The final StepResult.feedback string must contain the substring "ValueError: Internal error".
+    """
+    failing_agent = FailingAgent()
+
+    step = Step.model_validate(
+        {
+            "name": "failing_step",
+            "agent": failing_agent,
+            "config": StepConfig(max_retries=1, timeout_s=30),
+        }
+    )
+
+    pipeline = Pipeline(steps=[step])
+    flujo = create_test_flujo(pipeline, context_model=PipelineContext)
+
+    # Run the pipeline
+    async for result in flujo.run_async(
+        "test_data", initial_context_data={"initial_prompt": "test prompt"}
+    ):
+        pass
+
+    # Verify the step failed
+    step_result = get_step_result(result)
+    assert not step_result.success
+
+    # FR-36: Verify the feedback contains the actual error type and message
+    assert "ValueError: Internal error" in step_result.feedback
+    assert "Agent execution failed with ValueError" in step_result.feedback
+
+
+@pytest.mark.asyncio
+async def test_backward_compatibility_existing_context_aware():
+    """Test that existing context-aware agents continue to work correctly.
+
+    This ensures NFR-14: Existing pipelines with correctly defined context-aware agents
+    must continue to function without any changes.
+    """
+    context_aware_agent = ContextAwareAgent()
+
+    step = Step.model_validate(
+        {
+            "name": "backward_compat_step",
+            "agent": context_aware_agent,
+            "config": StepConfig(max_retries=1, timeout_s=30),
+        }
+    )
+
+    pipeline = Pipeline(steps=[step])
+    flujo = create_test_flujo(pipeline, context_model=PipelineContext)
+
+    # Run the pipeline
+    async for result in flujo.run_async(
+        "test_data", initial_context_data={"initial_prompt": "test prompt"}
+    ):
+        pass
+
+    # Verify the step succeeded (backward compatibility maintained)
+    step_result = get_step_result(result)
+    assert step_result.success
+    assert step_result.feedback is None
+
+    # Verify the agent received context as expected
+    context_aware_agent.run_mock.assert_called_once()
+    call_args = context_aware_agent.run_mock.call_args
+    assert "context" in call_args[1]
+    assert call_args[1]["context"].initial_prompt == "test prompt"
+
+
+@pytest.mark.asyncio
+async def test_mixed_pipeline_stateless_and_context_aware():
+    """Test a pipeline with both stateless and context-aware agents.
+
+    This ensures that the signature-aware injection works correctly in mixed scenarios.
+    """
+    stateless_agent = StatelessAgent()
+    context_aware_agent = ContextAwareAgent()
+
+    step1 = Step.model_validate(
+        {
+            "name": "stateless_step",
+            "agent": stateless_agent,
+            "config": StepConfig(max_retries=1, timeout_s=30),
+        }
+    )
+
+    step2 = Step.model_validate(
+        {
+            "name": "context_aware_step",
+            "agent": context_aware_agent,
+            "config": StepConfig(max_retries=1, timeout_s=30),
+        }
+    )
+
+    pipeline = Pipeline(steps=[step1, step2])
+    flujo = create_test_flujo(pipeline, context_model=PipelineContext)
+
+    # Run the pipeline
+    async for result in flujo.run_async(
+        "test_data", initial_context_data={"initial_prompt": "test prompt"}
+    ):
+        pass
+
+    # Verify the pipeline succeeded
+    step_result = get_step_result(result)
+    assert step_result.success
+    assert step_result.feedback is None
+
+    # Verify stateless agent was called without context
+    stateless_agent.run_mock.assert_called_once()
+    stateless_call_args = stateless_agent.run_mock.call_args
+    assert "context" not in stateless_call_args[1]
+
+    # Verify context-aware agent was called with context
+    context_aware_agent.run_mock.assert_called_once()
+    context_call_args = context_aware_agent.run_mock.call_args
+    assert "context" in context_call_args[1]
