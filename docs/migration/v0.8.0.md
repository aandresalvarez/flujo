# Migration Guide: v0.8.0 — First-Class Quotas and Estimation Telemetry

This release introduces proactive, policy-driven budgeting with a first-class `Quota`, pluggable usage estimation, and expanded telemetry. It preserves legacy error message parity while deprecating reactive usage checks in favor of reservation-first execution.

## Summary of Changes
- Quota-based budgeting: Steps reserve budget before execution and reconcile after.
- Deterministic parallel budgeting: `Quota.split(n)` allocates sub-quotas to branches; parent is zeroed to prevent double-spend.
- Loop budgeting: Iterations share the same quota; each body reserves and reconciles, keeping total usage bounded.
- Estimation layer: Pluggable `UsageEstimator` with registry/factory and TOML overrides under `[cost.estimators.<provider>.<model>]`.
- Telemetry: New low-overhead events and counters to calibrate estimates and track denials.
- Deprecation: Reactive non-parallel usage checks are deprecated in favor of reservation-first policies. `_ParallelUsageGovernor` remains during transition.

## Opt-in and Configuration
- Enable budgeting by providing `UsageLimits` to your Runner (no code changes required in steps/pipelines):
  - If `UsageLimits` is omitted, execution behaves as before (no proactive reservations).
- Configure estimator hints in `flujo.toml`:

```toml
[cost.estimators.openai."gpt-4o"]
expected_cost_usd = 0.12
expected_tokens  = 600

[cost.estimators.openai."gpt-3.5-turbo"]
expected_cost_usd = 0.02
expected_tokens  = 300
```

- Advanced: Inject a custom estimator via `ExecutorCore(usage_estimator=...)` or a factory; see `docs/advanced/usage_estimation.md`.

## Telemetry and Counters
- Selection event: `[cost.estimator.selected]` (strategy, expected_tokens, expected_cost_usd)
- Reservation attempt: `[quota.reserve.attempt]` (estimate, remaining)
- Denial event: `[quota.reserve.denied]` (reason code)
- Reconciliation: `[quota.reconcile]` (actuals, deltas)
- Counters:
  - `estimator.usage{strategy}`
  - `quota.denials.total{code}`
  - `estimation.variance.count{type,bucket}`

Use these signals to identify high-variance steps and adjust TOML hints or swap in a different estimator.

## Behavior Differences and Compatibility
- Earlier failures: Some pipelines fail earlier (pre-execution) when estimates exceed remaining budget. Error messages remain legacy-compatible (e.g., “Cost limit of $X exceeded”).
- Parallel fairness: Sub-quotas enforce deterministic fairness across branches, avoiding races for the parent budget.
- Control-flow exceptions: `PausedException` and other control-flow exceptions are never transformed by reservation logic.
- Strict pricing: Strict pricing errors are preserved and not masked by reservation/reconciliation.

## Migration Steps
1. Provide `UsageLimits` to your Runner in staging and enable verbose telemetry.
2. Add TOML overrides for your most common providers/models to reduce denial noise.
3. Validate parallel and loop-heavy pipelines using the cookbook recipes:
   - `docs/cookbook/deterministic_parallel_quota.md`
   - `docs/cookbook/safe_loop_budgeting.md`
4. Monitor counters for denials and estimation variance; refine configuration or plug in a tailored estimator.
5. Remove any app-level reactive usage checks that duplicate the new reservation-first behavior.

## Known Transition Notes
- `_ParallelUsageGovernor` may remain in effect while tests transition; it will be removed once deterministic split policies are fully adopted project-wide.
- Some tests that implicitly relied on post-usage summaries might need to assert pre-execution denial semantics instead.

## References
- Advanced guide: `docs/advanced/usage_estimation.md`
- Team guide: `FLUJO_TEAM_GUIDE.md` (control-flow exceptions, policy-driven design)

