 
# Flujo Strategic Roadmap: Enterprise Architecture Evolution (Revised)

| Project | Flujo |
| :--- | :--- |
| **Version** | 4.0 (Architecturally Hardened) |
| **Status** | **Ready for Implementation** |
| **Theme** | **From "Executor" to "Platform"** |

---

## 1. Governance Policy Layer (The "Security Guard")
**Priority:** üö® Critical (Immediate)
**Impact:** High | **Effort:** Low/Medium

### Concept
Currently, Flujo manages *Resource Limits* (Quotas) but lacks *Behavioral Guardrails*. A Governance Policy Layer acts as middleware, intercepting inputs and tool usage to enforce security rules (e.g., PII redaction, tool allow-listing) before the agent executes.

### Why it is Valuable
*   **Enterprise Requirement:** Regulated industries cannot use agents without guarantees that sensitive data won't leak to LLM providers or that destructive tools (e.g., `drop_table`) won't be called in wrong contexts.
*   **Architectural Hygiene:** Decouples security logic from prompt engineering.

### Implementation Strategy
*   **Location:** `flujo/application/core/step_coordinator.py`
*   **Mechanism:** Implement a **Middleware Pattern** within the `StepCoordinator`.
*   **Action:**
    1.  Define a `GovernancePolicy` protocol in `flujo/domain/interfaces.py`.
    2.  Update `StepCoordinator.execute_step` to iterate through registered policies before delegating to the backend.
    3.  **Built-in:** Create `PIIScrubbingPolicy` (using simple regex patterns by default, optional `presidio` dependency) to redact sensitive data in logs and prompts.

```python
# flujo/domain/interfaces.py
class PolicyDecision(Enum):
    ALLOW = "allow"
    DENY = "deny"
    REDACT = "redact"

class GovernancePolicy(Protocol):
    def inspect_input(self, context: PipelineContext, data: Any) -> tuple[PolicyDecision, Any]: ...
    def inspect_tool_call(self, tool_name: str, args: dict) -> PolicyDecision: ...
```

---

## 2. OpenAPI Skill Generator (The "Integration Gateway")
**Priority:** üöÄ High (Short-term)
**Impact:** High | **Effort:** Low

### Concept
Manual coding of skill wrappers is a bottleneck. This feature generates Flujo-compatible `Agent` or `Step` definitions automatically from Swagger/OpenAPI JSON specifications.

### Why it is Valuable
*   **Developer Velocity:** instant integration with internal microservices.
*   **Type Safety:** Auto-generated Pydantic models ensure IO matches the API spec perfectly, leveraging Flujo's strong typing.

### Implementation Strategy
*   **Location:** `flujo/cli/dev_commands_experimental.py`
*   **Mechanism:** Code Generation (not dynamic runtime loading) to preserve IDE support.
*   **Action:**
    1.  New CLI command: `flujo dev import-openapi <url> --output-dir skills/generated`.
    2.  Use `datamodel-code-generator` to parse schemas.
    3.  Generate Python files that output standard `AsyncAgentWrapper` factories, ready to be used in `make_agent_async`.
    4.  Ensure generated code includes `output_type` definitions for validation.

---

## 3. Episodic Memory & RAG (The "Second Brain")
**Priority:** üß† Strategic (Medium-term)
**Impact:** Very High | **Effort:** Medium

### Concept
Agents need to recall facts across different pipeline runs. Unlike short-term conversation history, this is long-term semantic storage.

### Architectural Correction: The "Split State" Pattern
*   **Risk Avoided:** We will **not** bake vector logic into `StateBackend`. Execution state (transactional/write-heavy) must remain distinct from Semantic Memory (analytical/read-heavy).
*   **Implementation:**
    1.  **Interface:** Define `VectorStoreProtocol` in `flujo/domain/interfaces.py`.
    2.  **Infrastructure:** Create `flujo/infra/memory/` for implementations (e.g., `PGVectorStore`, `ChromaStore`, `InMemoryVectorStore`).
    3.  **Context:** Update `PipelineContext` to hold a reference to the store, exposing a `retrieve(query)` method.
    4.  **Persistence:** The `StateManager` handles saving execution artifacts; a new `MemoryManager` handles embedding and indexing successful step outputs *asynchronously*.

```python
# flujo/domain/interfaces.py
class VectorStoreProtocol(Protocol):
    async def search(self, query_vector: list[float], limit: int) -> list[Memory]
    async def add(self, memories: list[Memory]) -> None
```

---

## 4. Abstracted Sandboxed Execution (The "Safety Net")
**Priority:** üõ°Ô∏è Strategic (Medium-term)
**Impact:** High | **Effort:** High

### Concept
Safe execution of arbitrary code generated by LLMs.

### Architectural Correction: Interface-First Design
*   **Risk Avoided:** We will **not** hard-depend on the Docker SDK. Requiring a Docker daemon breaks compatibility with serverless environments (AWS Lambda, Cloud Run) and complicates local dev.
*   **Implementation:**
    1.  **Interface:** Define `SandboxProtocol` in `flujo/domain/interfaces.py` with methods like `exec_code(code, lang)`.
    2.  **Remote-First Default:** Implement `RemoteSandbox` (targeting APIs like E2B or a generic sidecar container) as the primary recommendation for production.
    3.  **Optional Docker:** Implement `DockerSandbox` as an optional extra (`pip install flujo[docker]`) for local development where the daemon is available.
    4.  **Skill:** Expose this via a standard skill `flujo.builtins.code_interpreter` that accepts the configured sandbox implementation.

---

## 5. Shadow Evaluations (The "Quality Control")
**Priority:** üìä Operational (Long-term)
**Impact:** Medium | **Effort:** Medium

### Concept
Asynchronous scoring of production runs using an LLM-as-a-Judge.

### Architectural Correction: Cost Control
*   **Risk Avoided:** Running evals on *every* production trace effectively doubles inference costs.
*   **Implementation:**
    1.  **Configuration:** Add `sampling_rate` (0.0 to 1.0) and `evaluate_on_failure` (bool) to the `[eval]` section of `flujo.toml`.
    2.  **Mechanism:** In `ExecutionManager.persist_and_finalize`, check the sampling logic.
    3.  **Async Dispatch:** If sampled, trigger `BackgroundTaskManager` to launch the Evaluator agent.
    4.  **Storage:** Write scores to a dedicated `evaluations` table linked to `run_id`, keeping the main `workflow_state` table clean.

---

## Summary Matrix

| Feature | Impact | Effort | refined Architecture Note |
| :--- | :--- | :--- | :--- |
| **1. Governance Policies** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | üü¢ Low | Implemented as **Middleware** in Coordinator. |
| **2. OpenAPI Generator** | ‚≠ê‚≠ê‚≠ê‚≠ê | üü¢ Low | **Code Gen** approach for type-safety. |
| **3. Episodic Memory** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | üü° Med | **Decoupled** `VectorStoreProtocol` (separate from State). |
| **4. Shadow Evals** | ‚≠ê‚≠ê‚≠ê | üü° Med | Added **Sampling Rates** to prevent cost explosion. |
| **5. Sandboxing** | ‚≠ê‚≠ê‚≠ê‚≠ê | üî¥ High | **Protocol-based**, treating Docker as an optional plugin. |
 